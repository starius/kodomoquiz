local c2 = {}

function c2.stack_var(req)
    return
    [[
    int main() {
        int foo = 5;
        return foo;
    }
    ]],
    'стековая',
    'статическая',
    'динамическая',
    'пассивная',
    [[К какому типу принадлежит переменная foo в следующем коде?]]
end

function c2.static_var(req)
    return
    [[
    int foo = 5;
    int main() {
        return foo;
    }
    ]],
    'статическая',
    'стековая',
    'динамическая',
    'активная',
    [[К какому типу принадлежит переменная foo в следующем коде?]]
end

function c2.dynamic_var(req)
    return
    '',
    'динамическая',
    'статическая',
    'стековая',
    'переменная',
    [[За удалением переменных какого типа должен следить
    программист (а не компилятор)?]]
end

function c2.uninitialized(req)
    return
    [[
    #include <stdio.h>

    int main() {
        int foo;
        printf("%i\n", foo);
    }
    ]],
    'произвольное значение',
    '0',
    'ошибка',
    'ничего',
    [[Что находится в неинициализированной числовой переменной?]]
end

function c2.recursion(req)
    return
    '',
    [[
    int foo(int x, int y) {
        if (x == 0) {
            return y;
        } else {
            return foo(x / 2, y * 2);
        }
    }
    ]],
    [[
    int bar(int x, int y) {
        return y * 2;
    }

    int foo(int x) {
        return bar(bar(x, x), bar(x, x));
    }
    ]],
    [[
    int foo(int x) {
        return x;
    }
    ]],
    [[
    int foo(int x) {
        return 0;
    }
    ]],
    [[Какая из этих функций foo является рекурсивной функцией?]]
end

function c2.no_return(req)
    return
    '',
    'возможны ошибки времени выполнения во время вызова такой функции',
    'ошибка компиляции',
    'будет такой же эффект, как будто функция вернула 0',
    'ничего',
    [[Что будет, если функция, возвращающая указатель, так ничего и не вернёт?]]
end

function c2.main_no_return(req)
    return
    '',
    'будет такой же эффект, как будто функция вернула 0',
    'возможны ошибки времени выполнения во время вызова такой функции',
    'ошибка компиляции',
    'ничего',
    [[Что будет, если функция main так ничего и не вернёт?]]
end

function c2.change_arguments(req)
    return
    [[
    #include <stdio.h>

    void foo(int x) {
        x = 2;
    }

    int main() {
        int x = 1;
        foo(x);
        printf("%i\n", x);
    }
    ]],
    '1',
    'произвольное значение',
    '2',
    'ничего',
    [[Что выведет такая программа?]]
end

function c2.int(req)
    return
    '',
    'int',
    'char',
    'float',
    'double',
    [[Как называется тип C, служащий для хранения целых чисел?]]
end

function c2.char(req)
    return
    '',
    'char',
    'int',
    'float',
    'double',
    [[Как называется тип C, служащий для хранения символов?]]
end

function c2.float(req)
    return
    '',
    'float',
    'char',
    'int',
    'double',
    [[Как называется тип C, служащий для хранения
    нецелых чисел одинарной точности?]]
end

function c2.double(req)
    return
    '',
    'double',
    'float',
    'char',
    'int',
    [[Как называется тип C, служащий для хранения
    нецелых чисел двойной точности?]]
end

function c2.static_array(req)
    return
    '',
    'во время компиляции',
    'во время запуска программы',
    'во время работы программы',
    'когда запускается функция, в которой объявлен этот массив',
    [[В какой момент фиксируется число элементов статического массива?]]
end

function c2.array(req)
    return
    '',
    'массив',
    'структура',
    'функция',
    'указатель',
    [[Какой тип данных C используется для хранения многих элементов
    одного типа?]]
end

function c2.struct(req)
    return
    '',
    'структура',
    'массив',
    'функция',
    'указатель',
    [[Какой тип данных C используется для группировки нескольких
    связанных переменных, которые могут быть как одного типа,
    так и разных?]]
end

function c2.pointer(req)
    return
    '',
    'указатель',
    'структура',
    'массив',
    'функция',
    [[В каком типе данных хранится адрес в памяти на
    какую-нибудь переменную?]]
end

function c2.selfpointer(req)
    return
    '',
    'можно',
    'нельзя',
    'зависит от типа указателя',
    'зависит от компилятора',
    [[Можно ли сделать указатель, в котором будет храниться
    его собственный адрес?]]
end

function c2.op_and(req)
    return
    '',
    '&&',
    'and',
    '||',
    '!',
    [[Как в C обозраначется операция И?]]
end

function c2.op_or(req)
    return
    '',
    '||',
    '&&',
    'or',
    '!',
    [[Как в C обозраначется операция ИЛИ?]]
end

function c2.op_not(req)
    return
    '',
    '!',
    '||',
    '&&',
    'not',
    [[Как в C обозраначется операция НЕ?]]
end

function c2.for_count(req)
    return
    [[
    int i;
    for (i = 1; i < 10; i++) {
        // do smth
    }
    ]],
    '9',
    '10',
    '11',
    '12',
    [[Сколько итераций включает следующий цикл?]]
end

function c2.indirection(req)
    return
    '',
    'переход от указателя к тому, на что он указывает',
    'переход к указателю от того, на что он указывает',
    'хранение адреса в памяти',
    'указатель',
    [[Что такое разыменование (indirection)?]]
end

function c2.indirection2(req)
    return
    '',
    '*',
    '&',
    '!',
    '~',
    [[Как обозначается разыменование?]]
end

function c2.indirection3(req)
    return
    '',
    '->',
    '&',
    '!',
    '~',
    [[Как обозначается разыменование
    указателя на структуру и переход к полю в этой
    структуре?]]
end

function c2.address_of(req)
    return
    '',
    'переход к указателю от того, на что он указывает',
    'переход от указателя к тому, на что он указывает',
    'перевод указателя к нулю',
    'такой операции нет',
    [[Что такое взятие адреса (Address-of Operator)?]]
end

function c2.address_of2(req)
    return
    '',
    '&',
    '*',
    '->',
    '^',
    [[Как обозначается операция взятия адреса?]]
end

return c2
